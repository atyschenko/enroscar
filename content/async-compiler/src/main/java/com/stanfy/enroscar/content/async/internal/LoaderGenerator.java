package com.stanfy.enroscar.content.async.internal;

import com.squareup.javawriter.JavaWriter;
import com.stanfy.enroscar.content.async.Async;

import java.io.IOException;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.EnumSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.ExecutableType;
import javax.lang.model.type.TypeMirror;

import static javax.lang.model.element.Modifier.*;

/**
 * @author Roman Mazur - Stanfy (http://stanfy.com)
 */
final class LoaderGenerator {

  /** Start value for loader ID. */
  static final int LOADER_ID_START = 3000;

  private static final String ANDROID_CONTEXT = "android.content.Context";
  private static final String LOADER_MANAGER = "android.support.v4.app.LoaderManager";

  /** Loader id counter. */
  private final AtomicInteger loaderId = new AtomicInteger(LOADER_ID_START);

  /** Class name. */
  private final String className;
  /** Package name. */
  private final String packageName;

  /** Base clas. */
  private final TypeElement baseClass;

  /** Methods. */
  private final List<ExecutableElement> methods;

  public LoaderGenerator(final ProcessingEnvironment env, final TypeElement type,
                         final List<ExecutableElement> methods) {
    this.baseClass = type;
    this.packageName = env.getElementUtils().getPackageOf(type).getQualifiedName().toString();
    this.className = Utils.getGeneratedClassName(packageName, type.getQualifiedName().toString());
    this.methods = methods;
  }

  public String getFqcn() {
    if (packageName.length() == 0) {
      return className;
    }
    return packageName + "." + className;
  }

  public void generateTo(final Writer out) throws IOException {
    JavaWriter w = new JavaWriter(out);

    w.emitSingleLineComment("Code generated by Enroscar. Do not edit. %s",
        new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));
    w.emitPackage(packageName);

    w.emitImports(ANDROID_CONTEXT);
    w.emitImports(LOADER_MANAGER);
    w.emitImports(Async.class, AsyncContext.class, LoadAsync.class);
    w.emitEmptyLine();

    w.beginType(className, "class", modifiers(baseClass), baseClass.getSimpleName().toString());
    w.emitEmptyLine();

    w.emitField(ANDROID_CONTEXT, "context", EnumSet.of(PRIVATE, FINAL));
    w.emitField(LOADER_MANAGER, "loaderManager", EnumSet.of(PRIVATE, FINAL));
    w.emitEmptyLine();

    w.beginConstructor(constructorModifiers(),
        ANDROID_CONTEXT, "context", LOADER_MANAGER, "loaderManager");
    w.emitStatement("this.context = context");
    w.emitStatement("this.loaderManager = loaderManager");
    w.endConstructor();
    w.emitEmptyLine();

    for (ExecutableElement method : methods) {
      w.emitAnnotation(Override.class);
      w.beginMethod(GenUtils.getReturnType(method), method.getSimpleName().toString(),
          modifiers(method), parameters(w, method), null);
      w.emitStatement(loadBody(method, w));
      w.endMethod();
      w.emitEmptyLine();
    }

    w.endType();
  }

  // TODO: release method support
  private String loadBody(final ExecutableElement method, final JavaWriter w)
      throws IOException {
    StringBuilder result = new StringBuilder();
    ExecutableType execType = (ExecutableType) method.asType();
    DeclaredType returnType = (DeclaredType) execType.getReturnType();
    TypeMirror dataType = returnType.getTypeArguments().get(0);
    String dataTypeName = w.compressType(dataType.toString());
    result.append("return new ")
        .append(w.compressType(LoadAsync.class.getCanonicalName()))
        .append("<").append(dataTypeName).append(">(")
        .append("loaderManager, ")
        .append("new AsyncContext<").append(dataTypeName).append(">(")
        .append(callSuper(method)).append(", context), ")
        .append(loaderId.getAndIncrement())
        .append(")");
    return result.toString();
  }

  private List<String> parameters(final JavaWriter w, final ExecutableElement method) {
    ArrayList<String> res = new ArrayList<String>(method.getParameters().size());
    for (VariableElement arg : method.getParameters()) {
      TypeMirror type = arg.asType();
      res.add(w.compressType(type.toString()));
      res.add(arg.getSimpleName().toString());
    }
    return res;
  }

  private static String callSuper(final ExecutableElement method) {
    StringBuilder stmt = new StringBuilder()
        .append("super.").append(method.getSimpleName()).append("(");
    if (!method.getParameters().isEmpty()) {
      for (VariableElement arg : method.getParameters()) {
        stmt.append(arg.getSimpleName().toString()).append(", ");
      }
      stmt.delete(stmt.length() - 2, stmt.length());
    }
    stmt.append(")");
    return stmt.toString();
  }

  private static Set<Modifier> modifiers(final Element e) {
    Set<Modifier> modifiers = e.getModifiers();
    if (modifiers instanceof EnumSet) {
      return modifiers;
    }
    if (modifiers.isEmpty()) {
      return EnumSet.noneOf(Modifier.class);
    }
    return EnumSet.copyOf(modifiers);
  }

  private Set<Modifier> constructorModifiers() {
    Set<Modifier> m = modifiers(baseClass);
    return m.contains(PUBLIC) ? EnumSet.of(PUBLIC) : EnumSet.noneOf(Modifier.class);
  }

}
