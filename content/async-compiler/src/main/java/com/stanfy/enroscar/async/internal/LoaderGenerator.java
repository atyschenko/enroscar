package com.stanfy.enroscar.async.internal;

import com.squareup.javawriter.JavaWriter;
import com.stanfy.enroscar.async.Async;
import com.stanfy.enroscar.async.Load;
import com.stanfy.enroscar.async.Send;

import java.io.IOException;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.EnumSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.Name;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.ExecutableType;
import javax.lang.model.type.TypeMirror;

import static javax.lang.model.element.Modifier.*;

/**
 * @author Roman Mazur - Stanfy (http://stanfy.com)
 */
final class LoaderGenerator {

  // TODO: release method support

  /** Start value for loader ID. */
  static final int LOADER_ID_START = 3000;

  private static final String ANDROID_CONTEXT = "android.content.Context";
  private static final String LOADER_MANAGER = "android.support.v4.app.LoaderManager";

  /** Loader id counter. */
  private final AtomicInteger loaderId = new AtomicInteger(LOADER_ID_START);

  /** Class name. */
  private final String className;
  /** Package name. */
  private final String packageName;

  /** Base clas. */
  private final TypeElement baseClass;

  /** Methods. */
  private final List<ExecutableElement> methods;

  public LoaderGenerator(final ProcessingEnvironment env, final TypeElement type,
                         final List<ExecutableElement> methods) {
    this.baseClass = type;
    this.packageName = env.getElementUtils().getPackageOf(type).getQualifiedName().toString();
    this.className = Utils.getGeneratedClassName(packageName, type.getQualifiedName().toString());
    this.methods = methods;
  }

  public String getFqcn() {
    if (packageName.length() == 0) {
      return className;
    }
    return packageName + "." + className;
  }

  public void generateTo(final Writer out) throws IOException {
    JavaWriter w = new JavaWriter(out);

    w.emitSingleLineComment("Code generated by Enroscar. Do not edit. %s",
        new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));
    w.emitPackage(packageName);

    w.emitImports(ANDROID_CONTEXT);
    w.emitImports(LOADER_MANAGER);
    w.emitImports(
        Async.class, AsyncContext.class,
        AsyncProvider.class,
        LoadAsync.class, SendAsync.class
    );
    w.emitEmptyLine();

    w.beginType(className, "class", modifiers(baseClass), getExtendsType());
    w.emitEmptyLine();

    w.emitField(ANDROID_CONTEXT, "context", EnumSet.of(PRIVATE, FINAL));
    w.emitField(LOADER_MANAGER, "loaderManager", EnumSet.of(PRIVATE, FINAL));
    sendAsyncInFields(w);
    w.emitEmptyLine();

    w.beginConstructor(constructorModifiers(),
        ANDROID_CONTEXT, "context", LOADER_MANAGER, "loaderManager");
    w.emitStatement("this.context = context");
    w.emitStatement("this.loaderManager = loaderManager");
    sendAsyncInConstructor(w);
    w.endConstructor();
    w.emitEmptyLine();

    for (ExecutableElement method : methods) {
      w.emitAnnotation(Override.class);
      w.beginMethod(GenUtils.getReturnType(method), method.getSimpleName().toString(),
          modifiers(method), parameters(w, method), null);
      String body = method.getAnnotation(Load.class) != null
          ? loadBody(method, w)
          : sendBody(method, w);
      w.emitStatement(body);
      w.endMethod();
      w.emitEmptyLine();
    }

    w.endType();
  }

  private String getExtendsType() {
    return baseClass.getQualifiedName().toString();
  }

  private void sendAsyncInConstructor(final JavaWriter w)
      throws IOException {
    for (ExecutableElement m : methods) {
      if (m.getAnnotation(Send.class) == null) {
        continue;
      }
      w.emitEmptyLine();
      String base = m.getSimpleName().toString();
      String dataType = w.compressType(getDataType(m).toString());
      w.emitStatement("this.%sContext = new AsyncContext.DelegatedContext<%s>(context)",
          base, dataType);
      w.emitStatement("this.%sAsync = new SendAsync<%s>(loaderManager, this.%sContext, %d)",
          base, dataType, base, loaderId.getAndIncrement());
    }
  }

  private void sendAsyncInFields(final JavaWriter w)
      throws IOException {
    for (ExecutableElement m : methods) {
      if (m.getAnnotation(Send.class) == null) {
        continue;
      }
      w.emitEmptyLine();
      String base = m.getSimpleName().toString();
      String dataType = w.compressType(getDataType(m).toString());
      w.emitField("AsyncContext.DelegatedContext<" + dataType + ">", base + "Context",
          EnumSet.of(PRIVATE, FINAL));
      w.emitField(Async.class.getSimpleName() + "<" + dataType + ">", base + "Async",
          EnumSet.of(PRIVATE, FINAL));
    }
  }

  private String loadBody(final ExecutableElement method, final JavaWriter w)
      throws IOException {
    StringBuilder result = new StringBuilder();
    TypeMirror dataType = getDataType(method);
    String dataTypeName = w.compressType(dataType.toString());
    result.append("return new ")
        .append(w.compressType(LoadAsync.class.getCanonicalName()))
        .append("<").append(dataTypeName).append(">(")
        .append("loaderManager, ")
        .append("new AsyncContext.DirectContext<").append(dataTypeName).append(">(")
        .append(callSuper(method)).append(", context), ")
        .append(loaderId.getAndIncrement())
        .append(")");
    return result.toString();
  }

  private String sendBody(ExecutableElement method, JavaWriter w) {
    StringBuilder result = new StringBuilder();
    String dataType = w.compressType(getDataType(method).toString());
    Name base = method.getSimpleName();
    result.append("this.").append(base).append("Context.setDelegate(new ")
        .append(AsyncProvider.class.getSimpleName()).append("<").append(dataType).append(">() {")
        .append("@Override public ").append(Async.class.getSimpleName())
        .append("<").append(dataType).append("> provideAsync() {")
        .append("return ").append(className).append(".").append(callSuper(method)).append(";")
        .append("}});");
    result.append("return this.").append(base).append("Async");
    return result.toString();
  }

  private static TypeMirror getDataType(ExecutableElement method) {
    ExecutableType execType = (ExecutableType) method.asType();
    DeclaredType returnType = (DeclaredType) execType.getReturnType();
    return returnType.getTypeArguments().get(0);
  }

  private List<String> parameters(final JavaWriter w, final ExecutableElement method) {
    ArrayList<String> res = new ArrayList<String>(method.getParameters().size());
    for (VariableElement arg : method.getParameters()) {
      TypeMirror type = arg.asType();
      res.add("final " + w.compressType(type.toString()));
      res.add(arg.getSimpleName().toString());
    }
    return res;
  }

  private static String callSuper(final ExecutableElement method) {
    StringBuilder stmt = new StringBuilder()
        .append("super.").append(method.getSimpleName()).append("(");
    if (!method.getParameters().isEmpty()) {
      for (VariableElement arg : method.getParameters()) {
        stmt.append(arg.getSimpleName().toString()).append(", ");
      }
      stmt.delete(stmt.length() - 2, stmt.length());
    }
    stmt.append(")");
    return stmt.toString();
  }

  private static Set<Modifier> modifiers(final Element e) {
    Set<Modifier> modifiers = e.getModifiers();
    if (modifiers instanceof EnumSet) {
      return modifiers;
    }
    if (modifiers.isEmpty()) {
      return EnumSet.noneOf(Modifier.class);
    }
    final EnumSet<Modifier> resultSet = EnumSet.copyOf(modifiers);
    resultSet.remove(STATIC);
    return resultSet;
  }

  private Set<Modifier> constructorModifiers() {
    Set<Modifier> m = modifiers(baseClass);
    return m.contains(PUBLIC) ? EnumSet.of(PUBLIC) : EnumSet.noneOf(Modifier.class);
  }

}
